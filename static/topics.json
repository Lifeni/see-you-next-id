{"success":true,"data":[{"id":"5db261bdece3813ad9ba424b","author_id":"5dab3db2ece3813ad9ba2eca","tab":"ask","content":"用户通过第三方应用（如Github）登录时，如果为新用户，那么跳转到确认用户信息页面，第三方应用返回的用户信息是不是应该用redis做缓存才行？要不确认用户信息页面怎么能知道第三方返回的用户信息呢？\r\n谢谢！","title":"【新手】用户注册时分两个步骤，请问临时数据是不是要用redis来保存？","last_reply_at":"2019-10-25T02:45:17.044Z","good":false,"top":false,"reply_count":0,"visit_count":208,"create_at":"2019-10-25T02:45:17.044Z","author":{"loginname":"sytana","avatar_url":"https://avatars2.githubusercontent.com/u/11701135?v=4&s=120"}},{"id":"5dae61cc865a9844a301ccb9","author_id":"5dae61a8865a9844a301ccb4","tab":"share","content":"![969cd85b76a4fd422f1c7c1c6cf4ddc.png](//static.cnodejs.org/FsZiaTxdZ1pD9ETPS1HYx5J8IMEJ)","title":"欢迎大家加入Vue基础交流群，群里可以互相讨论技术也会共享视频教程。","last_reply_at":"2019-10-25T02:40:51.522Z","good":false,"top":false,"reply_count":11,"visit_count":997,"create_at":"2019-10-22T01:56:28.305Z","author":{"loginname":"uncledrewzhaopeng","avatar_url":"https://avatars0.githubusercontent.com/u/48023419?v=4&s=120"}},{"id":"5db1ad02865a9844a301d9d7","author_id":"5d92253c865a9844a3019496","tab":"share","content":"## 编程范式\r\n\r\n编程范式是：解决编程中的问题的过程中使用到的一种模式，体现在思考问题的方式和代码风格上。这点很像语言，语言本身会体现出不同国家的人的思考方式和行为模式。\r\n\r\n常见的编程范式有下面几种：\r\n\r\n- 命令式编程\r\n- 面向对象编程\r\n- 函数式编程\r\n\r\n除了这三个之外，我们还会接触到其他的编程范式，如：声明式。\r\n\r\n编程范式之间不是互斥关系，而是可以结合在一起使用的。我们往往需要结合各种编程范式来完成一个程序功能。\r\n\r\n在学习写代码的过程中，我们一般先接触命令式编程，然后学习面向对象编程，面向对象编程可以让我们很方便地处理更复杂的问题。这篇文章里，我们会介绍函数式编程。\r\n\r\n### 不同的编程范式有不同的代码表现\r\n\r\n![elevator.png](//static.cnodejs.org/FsjLL4hJGhS3I0jXJg8cwrFKDxZY)\r\n\r\n比如从来没有坐过电梯的人，第一次坐电梯，电梯在 10 楼，人在 1 楼，他会按下，让电梯下来。按错按钮是因为他用了祈使语，而不是把自己的想法提交出去。\r\n\r\n相似地，你写的代码就像电梯的按钮界面，是让自己或者他人阅读的。只有达成了相同的共识才能更好地理解。通过这次文章可以让大家更好地理解函数式编程。\r\n\r\n下面是几种编程范式的代码片段：\r\n\r\n```js\r\nconst app = 'github';\r\nconst greeting = 'Hi, this is ';\r\nconsole.log(greeting + app);\r\n```\r\n\r\n这是命令式编程，通过调用 `const` 和 `console.log` 进行赋值和输出。\r\n\r\n```js\r\nconst Program = function() {\r\n    this.app = 'github';\r\n    this.greeting = function() {\r\n        console.log('Hi, this is ' + this.app);\r\n    };\r\n};\r\nconst program = new Program();\r\nprogram.greeting();\r\n```\r\n\r\n这是面向对象编程，我们把整个程序抽象成现实生活中的一个对象，这个对象会包含属性和方法。通过类的概念，我们有了生成对象的一个工厂。使用 `new` 关键字创建一个对象，最后调用对象的方法，也能完成刚才我们用命令式编程完成的程序功能。\r\n\r\n```js\r\nconst greet = function(app) {\r\n    return 'Hi, this is ' + app;\r\n};\r\nconsole.log(greet('github'));\r\n```\r\n\r\n这是简单的函数式编程，通过函数的调用完成程序的功能。但是一般情况下的函数式编程会更复杂一些，会包含函数的组合。\r\n\r\n### 不同的编程范式适用的场景不同\r\n\r\n- 命令式编程：流程顺序\r\n- 面向对象编程：物体\r\n- 函数式语言：数据处理\r\n\r\n我们往往会在不同场景下使用不同的编程范式，通过编程范式的结合来实现一个程序。\r\n\r\n我们通过命令式编程去让程序按步骤地执行操作。\r\n\r\n面向对象编程则是把程序抽象成和现实生活中的物体一样的对象，对象上有属性和方法，通过对象之间的修改属性和调用方法来完成程序设计。\r\n\r\n而函数式编程则适用于数据运算和处理。\r\n\r\n再仔细看下之前的代码，我们就会发现这些编程范式往往是要结合起来使用的。\r\n\r\n```js\r\nconst app = 'github';\r\nconst greeting = 'Hi, this is ';\r\nconsole.log(greeting + app);\r\n```\r\n\r\n这个例子里面，除了命令式之外，我们还可以把前两句语句赋值解读成声明式编程。\r\n\r\n```js\r\nconst Program = function(app) {\r\n    this.app = app;\r\n    this.greeting = function() {\r\n        console.log('Hi, this is ' + this.app);\r\n    };\r\n};\r\nconst program = new Program('github');\r\nprogram.greeting();\r\n```\r\n\r\n这里例子里面，我们看到在类的 `greeting` 方法里面也用到了命令式的 `console.log`。在最后的执行过程中的 `program.greeing()` 也是命令式的。\r\n\r\n```js\r\nconst greet = function(app) {\r\n    return 'Hi, this is ' + app;\r\n};\r\nconsole.log(greet('github'));\r\n```\r\n\r\n## 函数式编程\r\n\r\n使用函数式编程可以大大提高代码的可读性。\r\n\r\n### 函数式编程的学习曲线\r\n\r\n你编写的每一行代码之后都要有人来维护，这个人可能是你的团队成员，也可能是未来的你。如果代码写的太过复杂，那么无论谁来维护都会对你炫技式的故作聪明的做法倍感压力。\r\n\r\n对于复杂计算的场景下，使用函数式编程相比于命令式编程有更好的可读性。\r\n\r\n![why.png](//static.cnodejs.org/FvfbQX7H_Rd9iH3RVR4fJSSaVGTp)\r\n\r\n从命令式的编程到函数式编程转换的道路上，可读性会变低，但是一旦度过了一个坎，也就是在你大量使用函数式编程时，可读性便会大大提升。可是我们往往会被这个坎阻挠，在发现可读性下降后放弃学习函数式编程。\r\n\r\n因此除了学习函数式编程本身的知识之外，我们还需要明白学习可能经历的过程和最终的结果。\r\n\r\n### 函数式编程定义\r\n\r\n函数是第一公民。\r\n\r\nJavaScript 是一门在设计之处就完全支持函数式编程的语言，在 JavaScript 里面，函数可以用 `function` 声明，作为全局变量，也就是这里说的“第一公民”。我们不再使用 `var`、`const` 或者 `let` 等关键字声明函数。我们也会大大减少变量的声明，通过函数的形参来替代变量的声明。\r\n\r\n函数式编程大量通过函数的组合进行逻辑处理，因此我们在后面会看到很多辅助函数。通过这些辅助函数，我们可以更方便得修改和组合函数。\r\n\r\n### 什么是函数？\r\n\r\n一个函数就是包含输入和输出的方程。数据流方向是从输入到输出。\r\n\r\n在数学里面我们学到的函数是这样的：\r\n\r\n```js\r\ny = f(x)\r\n```\r\n\r\n在 JavaScript 里面，函数是这样表示的：\r\n\r\n```js\r\nfunction(x) { return y; }\r\n```\r\n\r\n代码中的函数和数学意义上的函数概念是一样的。\r\n\r\n### 函数和程序的区别\r\n\r\n- 程序是任意功能的合集，可以没有输入值，可以没有输出值。\r\n- 函数必须有输入值和输出值。\r\n\r\n### 函数适合的场景\r\n\r\n函数适合：数学运算。不适合：与真实世界互动。\r\n\r\n实际的编程需要修改硬盘等。如果不改变东西，等于什么都没做。也就没办法完成任务了。\r\n\r\n### JavaScript 和函数式编程\r\n\r\nJavaScript 支持函数式编程。使用 JavaScript 进行函数式编程时，我们要使用 JavaScript 的子集。不使用 for 循环, Math.random, Date, 不修改数据，来避免副作用，做到函数式编程。\r\n\r\n下面，面向 JavaScript 开发者，介绍在 JavaScript 函数式编程中用到的一些概念。\r\n\r\n### 高阶函数\r\n\r\n高阶函数是由一个或多个函数作为输入的函数，或者是输出一个函数的函数。\r\n\r\n```js\r\n[1, 2, 3].map(function(item, index, array) {\r\n    return item * 2;\r\n});\r\n```\r\n\r\n```js\r\n[1, 2, 3].reduce(function(accumulator, currentValue, currentIndex, array) {\r\n    return accumulator + currentValue;\r\n}, 0);\r\n```\r\n\r\n`map` 和 `reduce` 是高阶函数，它接收一个函数作为参数。\r\n\r\n### 纯函数\r\n\r\n纯函数有两个特点：\r\n\r\n- 纯函数是幂等的\r\n- 纯函数没有副作用\r\n\r\n纯函数是可靠的，可预测结果。带来了可读性和可维护性。\r\n\r\n### 幂等\r\n\r\n幂等是指函数任意多次执行所产生的影响和一次执行的影响相同。函数的输入和输出都需要幂等。\r\n\r\n```js\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n上面的函数是幂等的。\r\n\r\n```js\r\nfunction add(a) {\r\n    return a + Math.random();\r\n}\r\n```\r\n\r\n上面使用了随机数，每次执行得到的结果不同，所以这个函数不幂等。\r\n\r\n```js\r\nvar a = 1;\r\nfunction add(b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n上面使用到函数外部的数据，当外部数据变化时，函数执行的结果不再相同，所以这个函数不幂等。\r\n\r\n```js\r\nvar c = 1;\r\nfunction add(a, b) {\r\n    c++;\r\n    return a + b;\r\n}\r\n```\r\n\r\n上面的函数修改了函数外部的数据，所以也不幂等。\r\n\r\n### 副作用\r\n\r\n副作用是当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。\r\n\r\n最常见的副作用是 I/O（输入/输出）。对于前端来说，用户事件（鼠标、键盘）是 JS 编程者在浏览器中使用的典型的输入，而输出的则是 DOM。如果你使用 Node.js 比较多，你更有可能接触到和输出到文件系统、网络系统和/或者 stdin / stdout（标准输入流/标准输出流）的输入和输出。\r\n\r\n### 纯函数\r\n\r\n一个纯函数需要满足下面两个条件：\r\n\r\n- 纯函数是幂等的\r\n- 纯函数没有副作用\r\n\r\n### 不可变数据\r\n\r\n不可变数据是指保持一个对象状态不变。\r\n\r\n值的不可变性并不是不改变值。它是指在程序状态改变时，不直接修改当前数据，而是创建并追踪一个新数据。这使得我们在读代码时更有信心，因为我们限制了状态改变的场景，状态不会在意料之外或不易观察的地方发生改变。\r\n\r\n在函数式和非函数式编程中，不可变数据对我们都有帮助。\r\n\r\n### 使用不可变数据的准则\r\n\r\n- 使用 `const`，不使用 `let`\r\n- 不使用 `splice`、`pop`、`push`、`shift`、`unshift`、`reverse` 以及 `fill` 修改数组\r\n- 不修改对象属性或方法\r\n\r\n### 使用不可变数据的弊端\r\n\r\n不可变数据有更多内存开销。\r\n\r\n![mutable-data.png](//static.cnodejs.org/FurolkOmO7cj9SbYvQUOF8V_y7Pz)\r\n\r\n修改数据的情况下，直接替换了变量的值，内存开销不变。\r\n\r\n![immutable-data.png](//static.cnodejs.org/FpBW2sNVQYMvKKdjyR8NUuKDT2DI)\r\n\r\n使用不可变数据后，我们复制了一个对象，内存开销翻倍。\r\n\r\n![immutable-data-with-helpers.png](//static.cnodejs.org/Fqg2lvDXmNVHF3UoXMZvBSN3mLCL)\r\n\r\n使用 immutableJS 等辅助库后，可以更好地利用之前的数据，优化了内存开销。\r\n\r\n### 闭包 vs 对象\r\n\r\n闭包和对象是一样东西的两种表达方式。一个没有闭包的编程语言可以用对象来模拟闭包；一个没有对象的编程语言可以用闭包来模拟对象。两者都可以用来维护数据。\r\n\r\n```js\r\nvar obj = {\r\n\tone: 1,\r\n\ttwo: 2\r\n};\r\n\r\nfunction run() {\r\n\treturn this.one + this.two;\r\n}\r\n\r\nvar three = run.bind(obj);\r\n\r\nthree();\t\t// => 3\r\n```\r\n\r\n```js\r\nfunction getRun() {\r\n\tvar one = 1;\r\n\tvar two = 2;\r\n\r\n\treturn function run(){\r\n\t\treturn one + two;\r\n\t};\r\n}\r\n\r\nvar three = getRun();\r\n\r\nthree();\t\t\t// => 3\r\n```\r\n\r\n上面两种方式都可以用来完成程序功能，对象和函数之间可以转换。\r\n\r\n### 常见的辅助函数\r\n\r\n- `unary`\r\n- `reverseArgs`\r\n- `curry`\r\n- `uncurry`\r\n- `compose`\r\n- `pipe`\r\n- `asyncPipe`\r\n\r\n`unary`，`reverseArgs`，`curry` 和 `uncurry` 是用来进行参数操作的。`compose`，`pipe` 和 `asyncPipe` 是用来进行函数组合的。\r\n\r\n#### `unary`\r\n\r\n`unary` 是用来限制某个函数只接收一个参数的。常见的使用场景是处理 `parseInt` 函数：\r\n\r\n```js\r\n['1', '2', '3'].map(parseInt);\r\n// => [1, NaN, NaN]\r\n```\r\n\r\n```js\r\n['1', '2', '3'].map(unary(parseInt));\r\n// => [1, 2, 3]\r\n```\r\n\r\n`unary` 的实现方式可以是：\r\n\r\n```js\r\nconst unary = (fn) => {\r\n    return (arg) => {\r\n        return fn(arg);\r\n    };\r\n};\r\n```\r\n\r\n#### `reverseArgs`\r\n\r\n`reverseArgs` 是用来讲函数参数反转的，实现方式如下：\r\n\r\n```js\r\nconst reverseArgs = (fn) => {\r\n    return (...args) => {\r\n        return fn(...args.reverse());\r\n    };\r\n};\r\n```\r\n\r\n#### `curry`\r\n\r\n`curry` 是用来把函数执行滞后的，让我们可以逐步把参数传入这个函数，当参数完整之后，目标函数才会执行。常见的用法如下：\r\n\r\n```js\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\nfunction add10(a) {\r\n    return add(10, a);\r\n}\r\nadd10(1); // => 11\r\n```\r\n\r\n通过 `curry` 函数，可以把上面的代码优化一下：\r\n\r\n```js\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\nconst curriedAdd = curry(add);\r\nconst add10 = curriedAdd(10);\r\nadd10(1); // => 11\r\n```\r\n\r\n`curry` 的实现思路如下：\r\n\r\n把 `args`，保存起来，每个 `curried` 函数接受一个参数，将参数拼在之前的参数后面。\r\n\r\n```js\r\nconst curry = (fn) => {\r\n    const curried = (curArg) => {\r\n        const args = [...prevArgs, curArg];\r\n        return curried;\r\n    };\r\n    return curried;\r\n};\r\n```\r\n\r\n修改成用闭包保存参数。\r\n\r\n```js\r\nconst curry = (fn) => {\r\n    return (curArg) => {\r\n        const args = [...prevArgs, curArg];\r\n        return nextCurried(...args);\r\n    };\r\n};\r\n```\r\n\r\n递归调用 `nextCurried`，第一次柯里化的函数不传入参数。\r\n\r\n```js\r\nconst curry = (fn) => {\r\n    const nextCurried = (...prevArgs) => {\r\n        return (curArg) => {\r\n            const args = [...prevArgs, curArg];\r\n            return nextCurried(...args);\r\n        };\r\n    };\r\n    return nextCurried();\r\n};\r\n```\r\n\r\n最后补全 `arity` 参数，来定义目标函数的参数数量。这样，我们可以定义柯里化后的参数数量，如果传入的参数数量到了函数需要的数量，则直接执行函数，并传入所有的参数。\r\n\r\n```js\r\nconst curry = (fn, arity = fn.length) => {\r\n    const nextCurried = (...prevArgs) => {\r\n        return (curArgs) => {\r\n            const args = [...prevArgs, curArgs];\r\n            if (args.length >= arity) {\r\n                return fn(...args);\r\n            }\r\n            return nextCurried(...args);\r\n        };\r\n    };\r\n    return nextCurried();\r\n};\r\n```\r\n\r\n或者我们可以实现一个支持传入多个参数的柯里化函数：\r\n\r\n```js\r\nconst curry = (fn, arity = fn.length) => {\r\n    const nextCurried = (...prevArgs) => {\r\n        return (...curArgs) => {\r\n            const args = [...prevArgs, ...curArgs];\r\n            if (args.length >= arity) {\r\n                return fn(...args);\r\n            }\r\n            return nextCurried(...args);\r\n        };\r\n    };\r\n    return nextCurried();\r\n};\r\n```\r\n\r\n#### `compose`\r\n\r\n`compose` 用来串联执行函数，执行顺序是从后向前的。与之对应的是 `pipe` 函数，同样是串联执行函数，但是执行顺序是从前向后的。\r\n\r\n`compose` 的用法：\r\n\r\n```js\r\nfunction add10(value) {\r\n    return value + 10;\r\n}\r\nfunction multiple10(value) {\r\n    return value * 10;\r\n}\r\nconst add10AndMultiple10 = compose(multiple10, add10);\r\nadd10AndMultiple10(1); // => 110\r\n```\r\n\r\n`compose` 的实现：\r\n\r\n```js\r\nconst compose = (...fns) => {\r\n    return fns.reduce((a, b) => {\r\n        return (...args) => {\r\n            return a(b(...args));\r\n        };\r\n    });\r\n};\r\n```\r\n\r\n或者通过 `reduceRight` 简单地从右边向左执行，这是更好理解的一种实现，但是有参数个数的限制。\r\n\r\n```js\r\nconst compose = (...fns) => {\r\n    return (input) => {\r\n        return fns.reduceRight((value, fn) => {\r\n            return fn(value);\r\n        }, input);\r\n    };\r\n};\r\n```\r\n\r\n#### `pipe`\r\n\r\n`pipe` 也是用来组合函数的，串联执行的顺序是从前向后，与 `compose` 相反。`pipe` 的实现可以是：\r\n\r\n```js\r\nconst pipe = (...fns) => {\r\n    return fns.reduceRight((a, b) => {\r\n        return (...args) => {\r\n            return a(b(...args));\r\n        }\r\n    });\r\n};\r\n```\r\n\r\n`pipe` 的用法如下：\r\n\r\n```js\r\nconst addA = (value) => {\r\n    return value + 'A';\r\n};\r\nconst addB = (value) => {\r\n    return value + 'B';\r\n};\r\npipe(addA, addB)('1') // => 1AB\r\n```\r\n\r\n#### `asyncPipe`\r\n\r\n对于异步函数来说，如果我们要串联执行，可以使用 `asyncPipe`。实现可以是：\r\n\r\n```js\r\nconst asyncPipe =  (...fns) => {\r\n    return fns.reduceRight((next, fn) => {\r\n        return (...args) => {\r\n            fn(...args, next);\r\n        };\r\n    }, () => {});\r\n};\r\n```\r\n\r\n用法是：\r\n\r\n```js\r\nconst addA = (value, next) => {\r\n    next(value + 'A', 'a');\r\n};\r\nconst addB = (value, anotherValue, next) => {\r\n    console.log(anotherValue);                      // => a\r\n    next(value + 'B');\r\n};\r\nconst consoleLog = (value, next) => {\r\n    console.log(value);\r\n};\r\nasyncPipe(addA, addB, consoleLog)('1');              // => 1AB\r\n\r\n```\r\n\r\n### 函数式编程在数据结构上的运用\r\n\r\n#### 实现链表\r\n\r\n主要思路是用函数闭包代替对象保存数据。\r\n\r\n```js\r\nconst createNode = (value, next) => {\r\n    return (x) => {\r\n        if (x) {\r\n            return value;\r\n        }\r\n        return next;\r\n    };\r\n};\r\n```\r\n\r\n```js\r\nconst getValue = (node) => {\r\n    return node(true);\r\n};\r\nconst getNext = (node) => {\r\n    return node(false);\r\n};\r\n```\r\n\r\n```js\r\nconst append = (next, value) => {\r\n    if (next === null) {\r\n        return createNode(value, null);\r\n    }\r\n    return createNode(getValue(next), append(getNext(next), value));\r\n};\r\nconst reverse = (linkedList) => {\r\n    if (linkedList === null) {\r\n        return null;\r\n    }\r\n    return append(reverse(getNext(linkedList)), getValue(linkedList));\r\n};\r\n```\r\n\r\n```js\r\nconst linkedList1 = createNode(1, createNode(2, createNode(3, null)));\r\nconst linkedList2 = reverse(linkedList1);\r\ngetValue(linkedList1);                      // => 1\r\ngetValue(getNext(linkedList1));             // => 2\r\ngetValue(getNext(getNext(linkedList1)));    // => 3\r\ngetValue(linkedList2);                      // => 3\r\ngetValue(getNext(linkedList2));             // => 2\r\ngetValue(getNext(getNext(linkedList2)));    // => 1\r\n```\r\n\r\n同样可以用函数式编程实现二叉树。\r\n\r\n### 总结\r\n\r\n希望大家能够通过学习函数式编程范式，加深对软件研发的理解，开拓视野，找到更多组织代码方式。\r\n\r\n函数式编程能够更好地组织业务代码中的数据处理，更多地复用了函数，减少了中间变量。\r\n\r\n但是函数式编程也有缺点，它增加了学习成本，需要大家理解高阶函数。\r\n\r\n### 参考资料\r\n\r\n- [Anjana Vakil: Learning Functional Programming with JavaScript - JSUnconf 2016](https://www.youtube.com/watch?v=e-5obm1G_FY)\r\n- [Anjana Vakil: Immutable data structures for functional JS - JSConf EU 2017](https://www.youtube.com/watch?v=Wo0qiGPSV-s)\r\n- [JavaScript 轻量级函数式编程](https://github.com/ikcamp/Functional-Light-JS)\r\n- [Douglas Crockford: Monads and Gonads (YUIConf Evening Keynote)](https://www.youtube.com/watch?v=dkZFtimgAcM)\r\n- [A Brief Intro to Functional Programming](https://io-meter.com/2017/05/29/A-Brief-Intro-to-Functional-Programming/)\r\n- [JavaScript 中的函数式编程](https://vivaxyblog.github.io/2017/05/19/functional-programming-in-javascript.html)","title":"JavaScript 函数式编程初窥","last_reply_at":"2019-10-24T15:24:53.791Z","good":false,"top":false,"reply_count":1,"visit_count":243,"create_at":"2019-10-24T13:54:10.130Z","author":{"loginname":"vivaxy","avatar_url":"https://avatars0.githubusercontent.com/u/4216856?v=4&s=120"}},{"id":"5d9eabdf865a9844a301a59c","author_id":"595d976b10d696af07768a24","tab":"ask","content":"* 启动方式\r\n![image.png](//static.cnodejs.org/FpfJDPCTjOcjzPCyfAm3yfdmfW9P)\r\n\r\n* alinode应用正常\r\n![image.png](//static.cnodejs.org/FsAbzvHsHfBdP0rna_mfd73WZZrb)\r\n\r\n* docker里的common-error.log有报错信息\r\n![image.png](//static.cnodejs.org/FiUTT_biK0sM1CNSb969I0z6VDVe)\r\n\r\n* alinode配置\r\n![image.png](//static.cnodejs.org/FpKi5H5UL-oGHqj7ljNxjqdzROM7)\r\n\r\n* alinode没有异常日志\r\n![image.png](//static.cnodejs.org/FhacK8sMDsirkEn6Ucpk2kdgmCcy)","title":"egg+docker单进程启动，alinode抓不到异常日志","last_reply_at":"2019-10-24T13:03:42.145Z","good":false,"top":false,"reply_count":3,"visit_count":994,"create_at":"2019-10-10T03:56:15.904Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5daf16faece3813ad9ba37fe","author_id":"5d92253c865a9844a3019496","tab":"share","content":"[customElements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) 是 Web Components 规范下的新 API，可以用来实现组件化开发。\r\n\r\n如果你的应用只用兼容最新的 Chrome 浏览器，那么用它来替代 React 或者 Vue 是一个不错的选择。\r\n\r\n## 基本用法\r\n\r\n组件声明在一个 HTML 文件中。组件包括样式（Style），节点（DOM）和交互逻辑（Script）。一个组件文件的基本结构如下：\r\n\r\n```html\r\n<template>\r\n  <style></style>\r\n  <div>DOM 节点</div>\r\n</template>\r\n<script>\r\n  const componentDocument = document.currentScript.ownerDocument;\r\n\r\n  class Component extends HTMLElement {\r\n\r\n    static get TAG_NAME() {\r\n      return 'component-tag-name';\r\n    };\r\n\r\n    constructor() {\r\n      super();\r\n      const shadow = this.attachShadow({ mode: 'closed' });\r\n      const content = componentDocument.querySelector('template').content.cloneNode(true);\r\n      shadow.appendChild(content);\r\n    }\r\n  }\r\n\r\n  customElements.define(Component.TAG_NAME, Component);\r\n</script>\r\n```\r\n\r\n其中 `template` 节点下包含样式（Style）和节点（DOM）。交互逻辑在 `script` 标签中。\r\n\r\n组件文件通过 `<link rel=\"import\" href=\"./component.html\">` 的方式引入 HTML 文件中。在 HTML 文件中使用组件的方式就是直接写组件标签。比如：\r\n\r\n```html\r\n<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0\">\r\n  <title>HTML</title>\r\n  <link rel=\"import\" href=\"./component.html\">\r\n</head>\r\n<body>\r\n<component-tag-name></component-tag-name>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 组件注册\r\n\r\n`customElements.define` API 用来组册组件，API 接受三个参数：组件标签名称、组件的类和组件继承的标签类型。如：\r\n\r\n```js\r\ncustomElements.define('expanding-list', ExpandingList, { extends: \"ul\" });\r\n```\r\n\r\n上面声明了一个标签为 `expanding-list` 的组件，组件的构造类是 `ExpandingList` 需要声明，组件继承 `ul` 标签的特性。\r\n\r\n## 组件构造类\r\n\r\n组件的构造类需要继承 `HTMLElement` 类，或者可以继承 `HTMLParagraphElement` 等 `HTMLElement` 的子类，如果继承了 `HTMLParagraphElement` 这个类，那么组件将拥有 `p` 标签的特性。\r\n\r\n```js\r\nclass Component extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadow = this.attachShadow({ mode: 'closed' });\r\n    const content = componentDocument.querySelector('template').content.cloneNode(true);\r\n    shadow.appendChild(content);\r\n  }\r\n}\r\n```\r\n\r\n组件内的构造函数是必须的，在构造函数内，我们先需要调用父类的构造函数，然后创建一个 [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM) 节点，再将组件模版内容添加到节点内。\r\n\r\n使用 Shadow DOM 可以做到组件内的样式和组件外的样式不互相干扰，可以让组件封装更彻底。\r\n\r\n我们可以通过 `document.currentScript.ownerDocument;` 来拿到模版自身的跟节点。\r\n\r\n## 组件属性\r\n\r\n组件可以像 HTML 标签一样使用属性。在组件中可以获取属性。\r\n\r\n```html\r\n<component-tag-name attr-name=\"attr-value\"></component-tag-name>\r\n```\r\n\r\n```js\r\nclass Component extends HTMLElement {\r\n  constructor() {\r\n    super();\r\n    const shadow = this.attachShadow({ mode: 'closed' });\r\n    const content = componentDocument.querySelector('template').content.cloneNode(true);\r\n    shadow.appendChild(content);\r\n    const attrValue = this.getAttribute('attr-name');\r\n  }\r\n}\r\n```\r\n\r\n## 组件生命周期\r\n\r\n- `connectedCallback` 组件挂载，组件初始化后和移动时会触发\r\n- `disconnectedCallback` 组件卸载\r\n- `adoptedCallback` 组件被移动到一个新的文档树\r\n- `attributeChangedCallback` 组件属性变化\r\n\r\n## 组件事件\r\n\r\n可以触发自定义事件。\r\n\r\n```html\r\n<template>\r\n  <style></style>\r\n  <button>组件事件</button>\r\n</template>\r\n<script>\r\n  const componentDocument = document.currentScript.ownerDocument;\r\n\r\n  class Component extends HTMLElement {\r\n\r\n    static get TAG_NAME() {\r\n      return 'component-tag-name';\r\n    };\r\n\r\n    static get BUTTON_CLICK() {\r\n      return 'button-click';\r\n    }\r\n\r\n    constructor() {\r\n      super();\r\n      const shadow = this.attachShadow({ mode: 'closed' });\r\n      const content = componentDocument.querySelector('template').content.cloneNode(true);\r\n      shadow.appendChild(content);\r\n      const button = shadow.querySelector('button');\r\n      button.addEventListener('click', () => {\r\n        this.dispatchEvent(new CustomEvent(Component.BUTTON_CLICK, { button }));\r\n      });\r\n    }\r\n  }\r\n\r\n  customElements.define(Component.TAG_NAME, Component);\r\n</script>\r\n```\r\n\r\n\r\n## 例子\r\n\r\n- [customElements 的基本例子](https://github.com/vivaxy/course/tree/master/native-api/custom-elements)\r\n- [用 customElements 实现的 indexedDB 示例](https://github.com/vivaxy/course/tree/master/native-api/custom-elements)","title":"基于 Custom Elements 的组件化开发","last_reply_at":"2019-10-24T11:25:10.235Z","good":false,"top":false,"reply_count":1,"visit_count":597,"create_at":"2019-10-22T14:49:30.502Z","author":{"loginname":"vivaxy","avatar_url":"https://avatars0.githubusercontent.com/u/4216856?v=4&s=120"}},{"id":"5dafe935865a9844a301d33f","author_id":"580f166dcf18d0333412d19a","tab":"ask","content":"请教一下，egg框架如果使用微服务有相应好用的插件吗？或者有木有例子可以请教一下呀，我搜了好多有关的东西因为没有这方面的经验不知道应该选用哪一个，谢谢各位！","title":"请问一下egg框架有有关微服务方面的方案吗？","last_reply_at":"2019-10-24T08:37:36.994Z","good":false,"top":false,"reply_count":4,"visit_count":562,"create_at":"2019-10-23T05:46:29.449Z","author":{"loginname":"hewentaowx","avatar_url":"https://avatars2.githubusercontent.com/u/22340341?v=4&s=120"}},{"id":"5d82db5b95464514f7ed7f93","author_id":"5cfdc81b95fcc914aa2673c8","tab":"share","content":"项目多版本并行开发，经常需要各种各样的测试环境，写了个系统用来一键创建测试环境\r\n\r\n主要流程就是：拉代码 --》 编译 --》 各种初始化 --》 打包成Docker镜像 --》 上传镜像 --》 调用K8S API创建资源 --》 调用DNS API创建解析 --》 最后提供给开发或者测试一个域名可以访问\r\n\r\n详细的内容可以看看这个：[https://ops-coffee.cn/s/Nxh7mwPJPlbL3R9MdlkO_A](https://ops-coffee.cn/s/Nxh7mwPJPlbL3R9MdlkO_A)\r\n\r\n![sre_images_20190912.01.png](//static.cnodejs.org/Fs54UCdE3tEfQmhNXUr7F-Dm5BI5)\r\n\r\n![sre_images_20190912.02.png](//static.cnodejs.org/Fp3ngEr1p0V44dWrfibiSi0r3clv)\r\n\r\n![sre_images_20190912.03.png](//static.cnodejs.org/FmSYVYA7Jp4HcxTCOA6G-Ujk4hNl)\r\n\r\n![sre_images_20190912.04.png](//static.cnodejs.org/FuMQ3qZ8rsdfGsBu76Oduuknrq--)","title":"我写了个系统，用来一键创建测试环境","last_reply_at":"2019-10-24T06:17:52.422Z","good":false,"top":false,"reply_count":9,"visit_count":3566,"create_at":"2019-09-19T01:35:23.051Z","author":{"loginname":"ops-coffee","avatar_url":"https://avatars1.githubusercontent.com/u/42868360?v=4&s=120"}},{"id":"5d9c2794865a9844a3019ee5","author_id":"5a4dd7e3ebc575dc49b27115","tab":"share","content":"qingwa（青蛙）是最近随手写的一个小玩意儿。之所以叫这名字，是因为不知道起什么名字好。青蛙抓虫子，也契合使用场景。然而英文frog已经在npm上被占用了，所以就干脆用拼音好了。\r\n\r\nqingwa能让Node.js console系列方法在终端下输出日志时能显示具体的文件名及行号。\r\n\r\n当一个模块很多文件时，调试日志太多还是比较麻烦的。有时候甚至都不知道对应的日志是从哪个文件中输出的。\r\n\r\n---\r\n\r\n> 项目地址：[https://github.com/sbfkcel/qingwa](https://github.com/sbfkcel/qingwa)\r\n\r\n反馈意见请在github上提。\r\n\r\n## 使用效果\r\n![qingwa demo](//static.cnodejs.org/FtHre2iramBzIpbmq4Z7tAiTdBoG)\r\n\r\n## 如何使用？\r\n\r\nqingwa的使用很简单，引入到项目中执行即可。\r\n\r\n### 安装\r\n\r\n```bash\r\nnpm install qingwa --save\r\n```\r\n### 使用\r\n在代码中引入并执行即可\r\n\r\n```javascript\r\nrequire('qingwa')();\r\n\r\nconsole.log('Hello');    // 此时终端输出的日志即是带有文件名和行号的\r\n```\r\n\r\n### 实现原理\r\n\r\n通过try...catch内嵌throw error定位到具体的位置，并对console系列方法进行再次封装。","title":"qingwa让console.log在终端显示文件名和行号","last_reply_at":"2019-10-24T05:56:27.485Z","good":false,"top":false,"reply_count":5,"visit_count":676,"create_at":"2019-10-08T06:07:16.300Z","author":{"loginname":"sbfkcel","avatar_url":"https://avatars1.githubusercontent.com/u/5469785?v=4&s=120"}},{"id":"5db10d5cece3813ad9ba3dc6","author_id":"54ed583a13a640c2725d8560","tab":"ask","content":"import('xxx'), 的代码没能分割\r\n如图： 有遇到的大佬么？\r\n![image.png](//static.cnodejs.org/FtJOCWZDI8ufOV6R5DPGEqMy2FRG)\r\n\r\n![image.png](//static.cnodejs.org/FuEEJRhraqsDPWGKizrvFdxmugh9)","title":"webpack4 使用模块异步加载的问题，import('xxx'), 的代码没能分割","last_reply_at":"2019-10-24T03:38:11.642Z","good":false,"top":false,"reply_count":1,"visit_count":203,"create_at":"2019-10-24T02:33:00.364Z","author":{"loginname":"weivea","avatar_url":"https://avatars3.githubusercontent.com/u/8197845?v=4&s=120"}},{"id":"5db113f5865a9844a301d711","author_id":"5807253a487e1e4578afb648","tab":"ask","content":"各位大牛好,小弟最近遇到一个server端短暂挂起的原因,想请教下各位.\r\n是这样的,我们的nodejs server有一个healthcheck机制,就是对外提供一个接口,然后我们有一个server会每过30秒去调用这个接口,看当前server的运行情况,超时时间为15秒,,如果超时会报警,目前遇到的问题是会突发性的出现报警信息,没有规律,间隔几个小时,我们猜测是server繁忙,没有响应healthcheck接口,但是我们看了server的内存和cpu占有率都是正常的,而且只会突发性的报一次警,我们也尝试抓了cpuprofile,但是都是在正常情况下抓的,所以没看出个所以然,我想请教各位大神有没有什么好的办法来分析这个问题,找出server不响应的根源","title":"求助:server端无响应问题","last_reply_at":"2019-10-24T03:01:09.077Z","good":false,"top":false,"reply_count":0,"visit_count":201,"create_at":"2019-10-24T03:01:09.077Z","author":{"loginname":"sx1989827","avatar_url":"https://avatars2.githubusercontent.com/u/5820929?v=4&s=120"}}]}